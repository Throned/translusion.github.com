<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on Trans lusion </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://translusion.github.com/posts/index.xml</link>
    <language>en-us</language>
    <author>Erik Engheim</author>
    
    <updated>Thu, 11 Dec 2014 00:00:00 UTC</updated>
    
    <item>
      <title>Why I don&#39;t believe in Torture</title>
      <link>http://translusion.github.com/posts/torture/</link>
      <pubDate>Thu, 11 Dec 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/torture/</guid>
      <description>

&lt;p&gt;This is a rather hillarious heading, because who in their right mind believes in torture. Most people will say &amp;ldquo;I support human rights&amp;rdquo;. But then there are those who come with a big BUT. But there are of course those exceptional cases they say where an attack is imminent and we could tward the terrorists from killing thousands. This might of course also question how valuable is really human rights which only extends to those you love or deem good people, while nasty people don&amp;rsquo;t get it. It is much like free speech. If you argue free speech should only be allowed to those who don&amp;rsquo;t say nasty things, then it isn&amp;rsquo;t free speech.&lt;/p&gt;

&lt;p&gt;Anyway the two common assumptions proponents of torture of terrorists indulge in is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;That you are always able to tell whether the terrorist is telling the truth or not.&lt;/li&gt;
&lt;li&gt;That you know that you got the right guy.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In a realistic scenario you don&amp;rsquo;t know who knows what. Say you got 10 terror suspects and one of them knows where the next attack is going to be. You don&amp;rsquo;t know who knows however and when you ask each of them, they all refuse to tell you. So you decide to torture every one of them to force them to talk. Now everyone of them wants to get away from the pain so they say whatever they think you want to hear. 9 of them has to invent something, because there is only 1 who actually knows. Problem is that now you have 10 different answers to your question.&lt;/p&gt;

&lt;p&gt;So the problem is that even if we assumed torture made people tell the truth if they know it, it wont help because the whole torture approach is producing so many false answers that you can&amp;rsquo;t tell when you got the right answer.&lt;/p&gt;

&lt;p&gt;Then there is silly assumption that the authorities can really know for sure whether they got the right person or not. As the Senate Committee&amp;rsquo;s Report on CIA&amp;rsquo;s use of torture details, one often apperhended innocents. In fact 20% of those detained did not even meet CIA&amp;rsquo;s own criteria for being detained.&lt;/p&gt;

&lt;p&gt;A great example of this is &lt;a href=&#34;http://en.wikipedia.org/wiki/Guildford_Four_and_Maguire_Seven#Guildford_Four&#34;&gt;&amp;ldquo;Guildford Four and Maguire Seven&amp;rdquo;&lt;/a&gt; who were convicted of the Guildford pub bombings of 5 October 1974. This later formed the basis of the famous movie &amp;ldquo;In the name of my father&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Convictions based on the use of torture. They were not released until 1991, when it was uncovered how the police had manipulated evidence and tortured the suspects into confessions. No doubt the police thought they had the right guys. When it started becoming clear they were wrong they covered up. That is third problem with torture. If one ever makes a mistake in torture, authorities will attempt to cover up the truth because the truth will be too much of an embarrasment. Just like the catholic chrurch has covered up their abuses because what could be more embarrassing that the guardians of moral displaying imoral.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;So in short I believe torture is wrong because when we torture we create a lot of false positives which hides the actual truth. Secondly because the principle of innocence exists not to be nice to bad guys but because it is very hard to know whether you got the right guy. That is why we have courts, to determine innocence. It stands to reasons that the graver the accusation the stronger the legal protection should be as the moral cost of wrongefully convicting someone of mass murder or terrorism is very high. Sadly many seem to conclude opposite. The more terrible the accusation you are subject to the less legal protection you deserve. With this form of logic, going over the speed limit on the highway should give someone the strongest legal defence.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Typing as a Paradigm</title>
      <link>http://translusion.github.com/posts/a_comparison_of_go_and_swift/</link>
      <pubDate>Mon, 08 Dec 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/a_comparison_of_go_and_swift/</guid>
      <description>

&lt;p&gt;The Dynamic vs Static Typing debate has been going on for decades and never seems to end. While I like both static and dynamic programming languages I probably have a slight preference for dynamic typing. However I feel of the two types of languages I feel the dynamic ones are the ones that are most profoundly misunderstood. The popular blog post &lt;a href=&#34;https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/&#34;&gt;Dynamic languages are static languages&lt;/a&gt; illustrates the misunderstanding very well.&lt;/p&gt;

&lt;p&gt;I think part of the problem is that when trying to articulate what the advantages of dynamic languages are it is easy to get very vague. So I am trying another approach.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Dynamic typing as a paradigm&lt;/h2&gt;

&lt;p&gt;In this post I will start by claiming that it is not so much about static vs dynamic languages but rather about two different paradigmes or approaches to programming. Much the same way as it can be argued that Object Oriented programming is a paradigme rather than a feature of a programming language. Many of you might already be familier with Object Oriented Programming in C. That is quite popular on Linux in the &lt;a href=&#34;http://www.gtk.org&#34;&gt;Gtk toolkit&lt;/a&gt; used on the Gnome desktop. Of course C as a language was not designed for this sort of programming the way say Java or Smalltalk was designed for it.&lt;/p&gt;

&lt;p&gt;The same argument could be made about static vs dynamic typing. You could write in a dynamic style in statically typed language. I&amp;rsquo;ve done that plenty of times. GUI based programming is often a good example. Static typing isn&amp;rsquo;t very well suited for this task and thus we got things like &lt;a href=&#34;http://qt-project.org&#34;&gt;Qt&lt;/a&gt; a C++ GUI toolkit which added a preprocessor which gave dynamic featues to C++. Objective-C did much the same earlier by adding dynamic features to C.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Objects as Hashtables&lt;/h2&gt;

&lt;p&gt;So how would you program in a more dynamic fashion in a statically typed language? One way which I have used a lot myself is to use hash tables more to define your objects rather than classes. This is essentially what an object is in Python or Ruby. In C++ or Java you could store your date in a hash table and create a number of functions or methods to manipulate this hash table much the same way as you create classes with corresponding methods. But why would you do that? You lose type safety. Of course but you also gain something:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You can easily iterate over the member of your object. Handy when applying a transformation to all members such as serializing them to disk, or duplicating them.&lt;/li&gt;
&lt;li&gt;You can add members at runtime.&lt;/li&gt;
&lt;li&gt;You can give rich meta data descriptions available at runtime for dynamic creation of e.g. GUIs.&lt;/li&gt;
&lt;li&gt;It can solve complicated problems with defining a proper taxonomy. Usually in Object Oriented programming we try to reuse code by creating an inheritance hierarchy so that we can share the implementation of methods which work in similar ways across types which are similar to each other. However a such a taxonomy might not always be easy to define. With hashtables it is easy to write a function which works on hash tables with different number of members as long as they share a common minimum of members that the function operates on.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The latter point was realized in &lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt; when they allowed satisfying interfaces implicitly. Point 3 allows creating such things as the &lt;em&gt;Predicate Editor&lt;/em&gt; found in Cocoa. One can imagine creating descriptions of each property saying what unit the property is in e.g. meters, kilo grams etc and what are legal value ranges. This can then be used to derive a GUI that allows viewing or editing corresponding objects. Visualization pipelines such as the &lt;a href=&#34;http://www.vtk.org&#34;&gt;Visualization Toolkit&lt;/a&gt; works along simular lines. You can at runtime connect algorithms sort of like Unix pipelines. To support an editor which lets humans connect different algorithms there needs to be a way to query each potential component in the pipeline and ask what sort of inputs and outputs they require. A compiler can&amp;rsquo;t check this sort of type information. First because it varies with the application domain what a type specifies and it needs to be determined at runtime for interactive usage.&lt;/p&gt;

&lt;p&gt;So a hash table with a bunch of functions is a way to simulate dynamic typing in a staticly typed languge, but thinking dynamic is more fundamental than that.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Pascal vs C&lt;/h2&gt;

&lt;p&gt;To illustrate the problem with strict typing I will go all the way back to Pascal. Pascal failed and C succeeded much because of Pascal&amp;rsquo;s embrace of the static typing over practicality mentality. Brian W. Kernighan wrote an article in 1981 called &lt;a href=&#34;http://www.lysator.liu.se/c/bwk-on-pascal.html&#34;&gt;Why Pascal is Not My Favorite Programming Language&lt;/a&gt; which illustrates many of these problems. In one of his examples he says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If one declares&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; var     arr10 : array [1..10] of integer;
         arr20 : array [1..20] of integer;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;then arr10 and arr20 are arrays of 10 and 20 integers respectively.  Suppose we want to write a procedure &amp;lsquo;sort&amp;rsquo; to sort an integer array.  Because arr10 and arr20 have different types, it is not possible to write a single procedure that will sort them both.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This might sound laughable by todays standards, but although it is perhaps and extreme example it is really just a variation of the same problem that one will often encounter with the static typing approach. Static typing allows the compiler to catch many mistakes you do before the code runs. Making the array lenght part of its type meant you would be less likely to get out of bounds errors or pass arrays of the wrong length around. But it also made it hard to reuse code and write generic functions.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;3D Graphics and OpenGL&lt;/h2&gt;

&lt;p&gt;When writing graphics code it would be tempting to make everything into types in much the same manner as Pascal. One might argue that a point in 2D space should be different from a point in 3D space or even 4D space. We could write types like this (julia syntax):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Point2D
  x :: Float64
  y :: Float64
end

type Point3D
  x :: Float64
  y :: Float64
  z :: Float64
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could then create array of 10 point objects like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;points2d = Array(Poin2D, 10)
points3d = Array(Point3D, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perhaps we want to perform rotation or translation of all these points with a matrix. The problem that now arises is much the same as with Pascal. If we define a function which transforms an array of points using a matrix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function transform(matrix :: Matrix, points :: Vector{Point2D})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then this can not be reused for an array of &lt;code&gt;Point3D&lt;/code&gt; points. Thus we get pascal style code duplication. Mathematically speaking matrix muliplication is a generic operation which we can write an algorithm for which perform the operation a matrix of any size. If we do not treat our points as types like &lt;code&gt;Point2D&lt;/code&gt; and &lt;code&gt;Point3D&lt;/code&gt; but just as arrays of numbers then we can transform an array of 10 2D points by just treating it as a matrix with 2 rows and 10 columns. &lt;code&gt;Point3D&lt;/code&gt; would be a matrix of 3 rows and 10 columns. This allows us to reuse standard fast matrix multiplication functions.&lt;/p&gt;

&lt;p&gt;OpenGL is a good example of this practice. There are no types for matricies or vectors. They are just arrays of numbers. This allows us to reuse OpenGL function for many cases.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Large Scale Programs&lt;/h2&gt;

&lt;p&gt;I hope that these simple examples in the small with Pascal arrays and matricies and vectors in 3D programming will allow you to get an intuition about how these problems also exist at a larger scale in most statically typed programs. When a large piece of software gets developed over many years by many different teams and pieces get bought and integrated there will be a lot of types which are similar but not quite the same, but which non the less needs to work together. We can imagine them like our 2D and 3D points. When they are separate types we will need to write a lot of conversion code to be able to reuse algorithms created for another type of object, or to be able to write some shared algorithm.&lt;/p&gt;

&lt;p&gt;With the dynamic approach this sort of problem usually disappear. That is the reason why glue languages are usually dynamic languages. Connecting different pieces of software that was not designed for each other gets quite tricky with a static language which insists on knowing everything about types at compile time. A concrete example of this is why a REPL for a statically typed language never can work as well as one for a dynamically typed one.&lt;/p&gt;

&lt;p&gt;In a dynamic language you can make structural changes at runtime. You can add or remove member variables of methods at runtime. That is fine because that does not change the type. For a statically typed language this poses a problem, since by adding or removing members you are changing the static type which all previous code was dependent on. The assumptions the compiler previously had about how to handle your types, would no longer be true and can thus not be allowed.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Not having done any research on this I can only speculate. But my speculation is that statically typed languages mainly work for medium sized programs while dynamic typing works for the small and high level. As your program grows it can get easier to mix up your types when you only use dynamic typing. So for larger size static typing has some advantages. However as a program gets even larger one gets into the problem of having to deal with many parts that were not designed for each other. This is where the flexibility of dynamically typed languages gains ground again.&lt;/p&gt;

&lt;p&gt;So perhaps a usefull design is to have chunks of statically typed code fittet together with a dynamically typed language which orchastrates everything at a high level.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Indispensable and Other Myths</title>
      <link>http://translusion.github.com/posts/CEO%20Salaries/</link>
      <pubDate>Mon, 10 Nov 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/CEO%20Salaries/</guid>
      <description>

&lt;p&gt;A lot of people assume that CEO salaries are completely determined by the market. But saying that something is determined by the market isn&amp;rsquo;t very informative. The market as described in Economic text books full or rational individuals with perfect information about the products they are buying rarely exists.&lt;/p&gt;

&lt;p&gt;Michael B. Dorff shows in his book &amp;ldquo;Indispensable and Other Myths&amp;rdquo; how the &amp;ldquo;market&amp;rdquo; for CEOs isn&amp;rsquo;t really a market. The most refreshing thing about the book I think is that he shows how essentially both sides of the debate about CEO salaries are quite wrong. The salaries are not determined by some highly efficient market which pays for talent, nor is it some sort of conspiracy to get as much money as possible.&lt;/p&gt;

&lt;p&gt;In a way Michael B. Dorff&amp;rsquo;s explanation for CEO salaries reminds me of &lt;a href=&#34;http://en.wikipedia.org/wiki/Hanlon&#39;s_razor&#34;&gt;Hanlon&amp;rsquo;s razor&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Never attribute to malice that which is adequately explained by stupidity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CEO pay is high essentially because everybody in charge of deciding CEO pay believes both that CEOs matter a lot to the fortunes of a company and that performance based pay is really effective for the sort of work a CEO does. The problem is turns out is that there isn&amp;rsquo;t really any evidence for any of this and the evidence that does exist typically shows no correlation or negative correlation.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;How did it all start?&lt;/h2&gt;

&lt;p&gt;It all essentially started with the economists Michael Jensen and William Meckling in the mid 1970s. They produced an extremely influential paper that argued that CEOs needed to get their pay tied to company performance to align themselves with the interests of the shareholders. Only problem was that this idea was based on flimsy evidence at the time and has never since been proven. Yet the intuinitive appeal was so strong that this idea soon spread to the boardrooms.&lt;/p&gt;

&lt;p&gt;The other problem is that board members easily get too carried away with increasing CEO compensation when hiring because there is strong belief that it is vital for the success of the company to get the very best CEO money can buy. Yet studies by Gabaix and Lanier, who were in favor of performance based pay showed that the difference between the best CEO and the 250th best was 0.016 percent. Meaning if one replaced the 250th best CEO with the best, then the companies market capitalization would grow by 0.016 percent. That is just small of a difference to expect that a board member can spot such minute difference between two CEOs.&lt;/p&gt;

&lt;p&gt;So why do they keep doing it? One of the effects Michael B. Dorff talks about is one similar to the one where you find that if you ask every driver about how good they are, then 90 percent will say they are better than the average. That is mathematically impossible. Board members are no better. They will typically believe they are above average and that they have superior ability to spot a good CEO.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Incentive based pay doesn&amp;rsquo;t work for intellectual tasks&lt;/h2&gt;

&lt;p&gt;Michael B. Dorff goes on to discuss a number of studies which shows that while performance based pay usually works with repetitive non-intelectual tasks it generally doesn&amp;rsquo;t work for more intelectually challenging work. And even when it works, it has so many side effects that it is often not worth it. One exampe he mentions is &lt;a href=&#34;http://hbswk.hbs.edu/item/3424.html&#34;&gt;HP&amp;rsquo;s experiments&lt;/a&gt; with performance based pay in the 90s.&lt;/p&gt;

&lt;p&gt;Incentive based pay reduced learning and mobility between teams. Team members became too focused on the metrics being measured at the detriment of everything else. When teams exceeded expectations according to metrics that would eventually force management to increase the requirements to meet the goals to get costs under control. However that would often cause resentment because employees now struggled with achieving what they had normally achieved. This issues led to management having to spend an exorbiant amount of time on tweaking and modifying incentives. In the end they concluded it was not worth it and all the branches of HP which had introduced performance based pay had abandoned it within 3 years.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;When reading &amp;ldquo;Indispensable and Other Myths&amp;rdquo; I can&amp;rsquo;t help but thinking that the reason we are so stuck with these approaches that doesn&amp;rsquo;t work like excessive CEO pay is that we are too eager to trust common sense. It makes common sense that performance based pay works and that CEOs are important. Perhaps it is worth remembering one of Albert Einstein&amp;rsquo;s quotes:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Common sense is the collection of prejudices acquired by age eighteen.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In reasoning about the very large or the very small like galaxies or sub atomic particles our common sense is of no help because our brains developed never having to deal with object of this size. It is also well known that we are notoriously horrible about having an intuition about probablity and statistics which are quite fundamental to studying anything like society, economics or CEO pay.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An introduction to Swift for Python developers</title>
      <link>http://translusion.github.com/posts/swift_compared_to_python/</link>
      <pubDate>Sat, 08 Nov 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/swift_compared_to_python/</guid>
      <description>

&lt;p&gt;While Swift fundamentally isn&amp;rsquo;t very much like Python, it looks as if it has a number of similarities on the surface. For instance both have different REPL environments. These are great ways of learning how to code. I can use the Python REPL as a calculator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 2 + 3
5
&amp;gt;&amp;gt;&amp;gt; 10 + 2 - 5
7
&amp;gt;&amp;gt;&amp;gt; 3.5 * 2
7.0
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do much the same with Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1&amp;gt; 2 + 3
$R0: Int = 5
  2&amp;gt; 10 + 2 - 5
$R1: Int = 7
  3&amp;gt; 3.5 * 2
$R2: Double = 7
  4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although this is quite similar, we can already get a hint here that Swift is different and cares a lot more about type. Along with all results we can see that Swift derives the type of the result. Swift is however a lot stricter language. In Python I can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = 4
&amp;gt;&amp;gt;&amp;gt; y = 5
&amp;gt;&amp;gt;&amp;gt; z = x + y
&amp;gt;&amp;gt;&amp;gt; z
9
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Despite the fact that &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; does not exist already. By assigning we created them. So there is no way to avoid having the accident of thinking you are assigning to a new variable when in fact you are overwriting the value of an existing one. In Swift if we try this we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    4&amp;gt; x = 4
error: use of unresolved identifier &#39;x&#39;
x = 4
^

    4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead we have to write &lt;code&gt;var&lt;/code&gt; to indicate we are creating a new variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 4&amp;gt; var x = 4
x: Int = 4
  5&amp;gt; var y = 5
y: Int = 5
  6&amp;gt; var z = x + y
z: Int = 9
  7&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can assign new values to these&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    7&amp;gt; x = 30
    8&amp;gt; x
$R3: Int = 30
    9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However if we made the variable constant by using &lt;code&gt;let&lt;/code&gt; we could not:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 12&amp;gt; let x = 4
x: Int = 4
 13&amp;gt; x = 5
error: cannot assign to &#39;let&#39; value &#39;x&#39;
x = 5
~ ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift is also a lot more strict about not mixing types. While you can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     13&amp;gt; 2.3 + 3
$R4: Double = 5.2999999999999998
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can&amp;rsquo;t do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 14&amp;gt; let x = 2.3
x: Double = 2.2999999999999998
 15&amp;gt; let y = 3
y: Int = 3
 16&amp;gt; x + y
error: cannot invoke &#39;+&#39; with an argument list of type &#39;(Double, Int)&#39;
x + y
~~^~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will have to explicitly convert the values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 17&amp;gt; x + Double(y)
$R6: Double = 5.2999999999999998
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Type annotation&lt;/h2&gt;

&lt;p&gt;Sometimes Swift will not be able to guess what type you wanted a variable to be. E.g. Swift could not know that &lt;code&gt;3&lt;/code&gt; was supposed to be a &lt;code&gt;Double&lt;/code&gt;. But what you can do is either write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1&amp;gt; let y = 3.0
y: Double = 3 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you could annotate the variable y with the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  2&amp;gt; let y : Double = 3
y: Double = 3 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Arrays and Dictionaries&lt;/h2&gt;

&lt;p&gt;One of the nice things about Python the batteries included approach. We get usefull data types like arrays and dictionaries built into the language. So we can easily create arrays and dictionaries and manipulate them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; numbers = [2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; squared = map(lambda x: x*x, numbers)
&amp;gt;&amp;gt;&amp;gt; squared[0:3]
[4, 16, 36] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift follows a similar philosophy and allows you to create collections of objects with succint syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  4&amp;gt; let numbers = [2, 4, 6, 8] 
numbers: [Int] = 4 values {
  [0] = 2
  [1] = 4
  [2] = 6
  [3] = 8
}
  5&amp;gt; let squared = map(numbers, {x in x*x}) 
squared: [Int] = 4 values {
  [0] = 4
  [1] = 16
  [2] = 36
  [3] = 64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see this is very similar. But Swift has a number of alternative ways to do this with ruby inspired syntax sugar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  8&amp;gt; let squared = map(numbers) {x in x*x}
squared: [Int] = 4 values {
  [0] = 4
  [1] = 16
  [2] = 36
  [3] = 64
}
  9&amp;gt; let squared = numbers.map {x in x*x} 
squared: [Int] = 4 values {
  [0] = 4
  [1] = 16
  [2] = 36
  [3] = 64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To slice arrays we can either do that with a closed &lt;code&gt;...&lt;/code&gt; or open interval &lt;code&gt;..&amp;lt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  6&amp;gt; squared[0...3]
$R0: Slice&amp;lt;Int&amp;gt; = 4 values {
  [0] = 4
  [1] = 16
  [2] = 36
  [3] = 64
}
  7&amp;gt; squared[0..&amp;lt;3]
$R1: Slice&amp;lt;Int&amp;gt; = 3 values {
  [0] = 4
  [1] = 16
  [2] = 36
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Functions&lt;/h2&gt;

&lt;p&gt;With python you can easily create a function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def add(a, b):
    return a + b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However that is not going to work in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 21&amp;gt; func add(a, b) { 
 22.     return a + b 
 23. }    
error: use of undeclared type &#39;a&#39;
func add(a, b) {
         ^
error: use of undeclared type &#39;b&#39;
func add(a, b) {
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because Swift needs to know what the type of your variables are. Unlike like our previous example where we assigned a value right away, there is no way for Swift to know what the type of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is going to be. It can&amp;rsquo;t infer it, so we have annotate the variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a: Int, b: Int) -&amp;gt; Int {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this has some limitations compared to the Python example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 4&amp;gt; add(2, 3)
$R0: Int = 5
  5&amp;gt; add(2.0, 3.3)
error: cannot convert the expression&#39;s type &#39;(FloatLiteralConvertible, FloatLiteralConvertible)&#39; to type &#39;Int&#39;
add(2.0, 3.3)
^~~~~~~~~~~~~
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Generics&lt;/h2&gt;

&lt;p&gt;Python allowed us to use any type of number, but now we have limited ourselves to integers. We can&amp;rsquo;t e.g. use float values. The Swift solution for this is Generics as found in C#, Java and many other languages. If this had been C++ I could have written something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add&amp;lt;T&amp;gt;(a: T, b: T) -&amp;gt; T {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To indicate that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can be of any type but they have to be of the same type &lt;code&gt;T&lt;/code&gt;. Likewise with the result. However this would give us the error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot invoke &#39;+&#39; with an argument list of type &#39;(T, T)&#39;
return a + b
       ~~^~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason being that an arbitrary type &lt;code&gt;T&lt;/code&gt; doesn&amp;rsquo;t support adding. C++ solves this problem by checking every use of &lt;code&gt;add()&lt;/code&gt; in the program and making sure only types which support &lt;code&gt;+&lt;/code&gt; is provided as arguments. But that is actually a terrible solution as it produces errors inside the function at the offending line. Thus users of a third party library has to understand how a third party function is implemented. So the Swift way of doing this is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add&amp;lt;T: Addable&amp;gt;(a: T, b: T) -&amp;gt; T {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To indicate that that the type &lt;code&gt;T&lt;/code&gt; has to implement the protocol &lt;code&gt;Addable&lt;/code&gt;. A protocol is like a C# or Java interface. It lists functions which any class which wants to adhere to the protocol has to implement. In this case we say that &lt;code&gt;T&lt;/code&gt; has to be of a type that support the &lt;code&gt;+&lt;/code&gt; operator. Unfortunatly no &lt;code&gt;Addable&lt;/code&gt; protocol exists in Swift. In fact Swift is at the moment quite lacking in protocols. The whole Swift standard library is quite tiny at the momment. So the above code will give the error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    error: use of undeclared type &#39;Addable&#39;
func add&amp;lt;T: Addable&amp;gt;(a: T, b: T) -&amp;gt; T {
            ^~~~~~~ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus we have to specify the &lt;code&gt;Addable&lt;/code&gt; protocol ourselves:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Addable {
    func +(a: Self, b: Self) -&amp;gt; Self
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The use of &lt;code&gt;Self&lt;/code&gt; looks strange. Self is a sort of placeholder for the type of the object the method is being invoked on. So e.g. when &lt;code&gt;+&lt;/code&gt; is being invoked on an &lt;code&gt;Int&lt;/code&gt; object then &lt;code&gt;Self&lt;/code&gt; is the same as &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we have the protocol but that only takes us half way. No concrete type is actually implementing this protocol. If this was Java or C++ that would be the end of this, because we would have had to implement our own number types somehow. Existing types can&amp;rsquo;t implement a new interface. Except in Swift you can. We can add methods to existing types or have existing types implement new protocols through extensions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Int: Addable {}
extension Double: Addable {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This specifies that &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt; implements &lt;code&gt;Addable&lt;/code&gt;. Notice we don&amp;rsquo;t have to actually implement any methods ourselves because &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt; already have the &lt;code&gt;+&lt;/code&gt; method/operator. Now we can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1&amp;gt; add(1, 2)
$R0: (Int) = 4
  2&amp;gt; add(2.0, 3.0)
$R1: (Double) = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However if we use a &lt;code&gt;Float&lt;/code&gt; we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  3&amp;gt; let x : Float = 2
x: Float = 2
  4&amp;gt; let y : Float = 3
y: Float = 3 
  5&amp;gt; add(x, y)
error: Type &#39;Float&#39; does not conform to protocol &#39;Addable&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get an error because we have not specified that &lt;code&gt;Float&lt;/code&gt; implements our &lt;code&gt;Addable&lt;/code&gt; protocol.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Comparison of the Go tour with Swift</title>
      <link>http://translusion.github.com/posts/dynamic_typing_as_a_paradigme/</link>
      <pubDate>Tue, 15 Jul 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/dynamic_typing_as_a_paradigme/</guid>
      <description>

&lt;p&gt;One of my favorite programming languages is Go, so I thought it might be fun to do a bit of a superficial comparison of it with Swift which I am hoping will be a new favorite given that I work professionally as an iOS developer. Go takes such a bare bones and simple approach to programming that one can quite quickly get a sense of what it is like using it. It will take longer time to make up an opinion about Swift.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;Hello world&lt;/h3&gt;

&lt;p&gt;The Go tour starts with the infamous &amp;ldquo;Hello world&amp;rdquo; program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;Hello, 世界&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see below Swift looks very similar at first glance. Although &lt;code&gt;main&lt;/code&gt; doesn&amp;rsquo;t have any special meaning. It is just a function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

func main() {
    println(&amp;quot;Hello, 世界&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we should rather replace the code with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

println(&amp;quot;Hello, 世界&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Import&lt;/h3&gt;

&lt;p&gt;In Go one divides the code into lots of small packages, which you can import as shown in the tour example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math/rand&amp;quot;
)

func main() {
    fmt.Println(&amp;quot;My favorite number is&amp;quot;, rand.Intn(10))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Swift we typically import large frameworks containg a number of libraries. For just simple math libraries &lt;code&gt;Foundation&lt;/code&gt; or &lt;code&gt;Cocoa&lt;/code&gt; isn&amp;rsquo;t needed. You can import e.g. the &lt;code&gt;Darwin&lt;/code&gt; framework.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Darwin

let favorite = rand() % 10
println(&amp;quot;My favorite number is&amp;quot;, favorite)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Functions&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func add(x int, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift is similar placing type info last instead of traditional C/C++ way of putting type first.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(x: Int, y: Int) -&amp;gt; Int {
    return x + y
}


println(add(42, 13))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;Multiple results&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
    fmt.Println(a, b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift doesn&amp;rsquo;t really return multiple values like Go functions but instead returns tuples which lets you accomplish basically the same thing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swap(x: String, y: String) -&amp;gt; (String, String) {
    return (y, x)
}

var (a, b) = swap(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
println(&amp;quot;\(a) \(b)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another minor difference is that Swift can do &lt;code&gt;println(a)&lt;/code&gt; but not &lt;code&gt;println(a, b)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;Named results&lt;/h3&gt;

&lt;p&gt;You can name the results in both Go and Swift but the meaning is very different, because Go has multiple return variables and Swift has tuples instead. In the Go example &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; can be assigned to directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}

func main() {
    fmt.Println(split(17))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can&amp;rsquo;t do that in Swift, because naming here has a different meaning. What you are doing is naming the entries in the tupple so, that you can refer to the entries later. It is sort of like making a struct on the fly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func split(sum: Int) -&amp;gt; (x: Int, y: Int) {
    var x = sum * 4 / 9
    var y = sum - x
    return (x, y)
}

var result = split(17)

println(result.x)
println(result.y)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;Variables&lt;/h3&gt;

&lt;p&gt;In Go &lt;code&gt;var&lt;/code&gt; start the definition of one or more variables with the type last.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i int
var c, python, java bool

func main() {
    fmt.Println(i, c, python, java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift is similar, except in Swift variables are never automatically initialized to 0 or false like in Go. If a variable is not initialized it is undefined and you are not allowed to use it. So you  must assign to it before you can read from it. Also multiple assignment relies on the tuple concept.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i: Int
var c, python, java: Bool
var (c, python, java) = (false, false, false)

println(&amp;quot;\(c) \(python) \(java)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So when doing initialization Go and Swift look more similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i, j int = 1, 2
var c, python, java = true, false, &amp;quot;no!&amp;quot;

func main() {
    fmt.Println(i, j, c, python, java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the difference that type annotations work a bit different. If you want every variable in the tupple to be of type &lt;code&gt;Int&lt;/code&gt; you have to specify that for each individual variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var (i: Int, j: Int)  = (1, 2)
var (c, python, java) = (true, false, &amp;quot;no!&amp;quot;)

println(&amp;quot;\(i) \(j) \(c) \(python) \(java)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tradeoff here is that that allows you to chose which variables you want infered and which ones you want to specify. So with Swift you could write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var (i: Float, j)  = (1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which would turn &lt;code&gt;i&lt;/code&gt; into a floating point number while &lt;code&gt;j&lt;/code&gt; would be infered to be an integer. Writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i Float64, j  = 1, 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in Go would be a compiler error. Type has to come last and apply to all variables.&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;Shorthand&lt;/h3&gt;

&lt;p&gt;In Go there is a shorthand notation using &lt;code&gt;:=&lt;/code&gt; when infering variables so you could write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;k := 3
c, python, java := true, false, &amp;quot;no!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There isn&amp;rsquo;t anything similar in Swift.&lt;/p&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;Type conversions&lt;/h3&gt;

&lt;p&gt;Both Swift and Go are much more strict on type conversions than what is traditional for C/C++. Conversion from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;float&lt;/code&gt; won&amp;rsquo;t happen automatically.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x, y int = 3, 4
var f float64 = math.Sqrt(float64(x*x + y*y))
var z int = int(f)
fmt.Println(x, y, z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift works similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var (x : Int, y : Int) = (3, 4)
var f : Float = sqrt(Float(x*x + y*y))
var z : Int = Int(f)
println(&amp;quot;\(x) \(y) \(z)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both Swift and Go can treat primitive types as first class citizens. You can create a type from a e.g. an &lt;code&gt;int&lt;/code&gt; in Go and add method to it. Swift is slightly different in this regard in that the most primitive types are not exposed directly. &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt; etc are really structs which may contain methods. Conversion from say &lt;code&gt;Float&lt;/code&gt; to &lt;code&gt;Int&lt;/code&gt; isn&amp;rsquo;t built into the language but rather exploits one of the initializer methods on the &lt;code&gt;Int&lt;/code&gt; type that takes a &lt;code&gt;Float&lt;/code&gt; as an argument.&lt;/p&gt;

&lt;p&gt;The example above could also be simplified. We don&amp;rsquo;t need to write types as often. Here is an example from a Swift REPL session, demonstrating this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swift
Welcome to Swift!  Type :help for assistance.
  1&amp;gt; var (x, y) = (3, 4)
x: Int = 3
y: Int = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the REPL will inform us that it infered the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to be of type &lt;code&gt;Int&lt;/code&gt;. Regular math functions such as &lt;code&gt;sqrt&lt;/code&gt; is in the &lt;em&gt;Darwin&lt;/em&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  2&amp;gt; import Darwin
  3&amp;gt; var f = sqrt(Float(x*x + y*y)) 
f: (Float) = 5
  4&amp;gt; var z = Int(f)
z: Int = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift infers that the result of &lt;code&gt;sqrt&lt;/code&gt; has to be of type &lt;code&gt;Float&lt;/code&gt; if the input is of type &lt;code&gt;Float&lt;/code&gt;. You can&amp;rsquo;t quite do the same in Go since Go does not overload functions on types.&lt;/p&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;Structs&lt;/h3&gt;

&lt;p&gt;Both Go and Swift support structs. There meaning is quite different however, since Swift is more like C# in that it has the notion of both structs and classes to deal with the lack of pointers. In Go it is idiomatic to access variables directly without accessors.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift we can&amp;rsquo;t access member variables directly. Although the code looks almost identical Swift always creates accessors conceptually. In machine code it might of course perform a direct access.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Vertex {
  var x : Int
  var y : Int
}

var v = Vertex(x: 1, y: 2)
v.x = 4
println(v.x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift initializers we also have to give the names of the arguments. With Go this is optional. The Go code could have been written like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v := Vertex{X: 1, Y: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A significant conceptual difference is that in Swift creating any object requires running an initializer function. In the Go example the data structure is just initialized directly. No function call is done. If you want an initialiser function for &lt;code&gt;Vertex&lt;/code&gt; objects in Go you have to write a free function explicity:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewVertex(x, y int) Vertex {
  return Vertex{x, y}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;Swift inout and Go pointers&lt;/h3&gt;

&lt;p&gt;Go has real pointers, but Swift allows you to things which makes it look as if it has pointers. Take this example of pointer usage in Go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swapXY(v *Vertex) {
    tmp := v.X
    v.X = v.Y
    v.Y = tmp
}

v := Vertex{1, 2}
swapXY(&amp;amp;v) // v becomes Vertex{2, 1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can do almost exactly the same in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swapXY(inout v: Vertex) {
   var tmp = v.x 
   v.x = v.y 
   v.y = tmp 
} 

var v = Vertex(x: 1, y: 2)
swapXY(&amp;amp;v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However except for when using unsafe features you can&amp;rsquo;t represent an inout function argument as a separate variable in Swift code the ampersand, only makes sense in the context of calling a function. So this will NOT work in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p = &amp;amp;v // error: type &#39;inout Vertex&#39; of variable is not materializable
swapXY(p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However Go has real pointers which allows you to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p := &amp;amp;v
swapXY(p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go pointers can be passed around and stored like any other variable. This also displays so key design differences between Swift and Go. Swift is generally designed to make code safe and prevent you from accidentally doing something dangerous or wrong. Because you have to prefix with ampersand at the call site it will always be clear to the code reader when you are potentially modifying a struct. Go instead opts for simplicity by having one simple feature which has many use cases.&lt;/p&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;Classes&lt;/h3&gt;

&lt;p&gt;This naturally brings us to classes. Classes is the way Swift allows us to simulate some of the properties of pointers in Go. If we defined &lt;code&gt;Vertex&lt;/code&gt; as a class instead of a struct we could perform the &lt;code&gt;swapXY&lt;/code&gt; without using &lt;code&gt;inout&lt;/code&gt; because variables of class types are always pointers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Vertex {
  var x : Int
  var y : Int

  // classes don&#39;t have initializers automatically made
  init(x: Int, y: Int) {
    self.x = x
    self.y = y
  }
}

// this works because v is now essentially a pointer
func swapXY(v: Vertex) {
   var tmp = v.x 
   v.x = v.y 
   v.y = tmp 
}

var v = Vertex(x: 1, y: 2)
swapXY(v) // Becomes Vertex(2, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So Swift structs allow us to use variables as values. Meaning they get copied with every assignment (except when using &lt;code&gt;inout&lt;/code&gt; arguments) while classes let use variables as pointers (assignment does not cause a copy). With Go we can manage with just &lt;code&gt;struct&lt;/code&gt; because we can make pointers to values using the ampersand operator.&lt;/p&gt;

&lt;p&gt;Other than that Swift classes works much the same as classes in other languages. It is what allows us to support implementation inheritance. Go does not support implementation inheritance. Go is not alone in this regard new languages like Clojure and Rust also tries to avoid inheritance. For Swift that was not an option as one of the important design goals was to be able to smoothly interface with Objective-C and existing Cocoa libraries which use inheritance hierarchies heavily.&lt;/p&gt;

&lt;p&gt;Both Swift and Go allows you to specify methods on structs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Vertex struct {
    X, Y float64
}

func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
    v := Vertex{3, 4}
    fmt.Println(v.Abs())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Go the methods are placed outside the struct, while in Swift they must be inside. To Go approach makes it easy to split method definitions over several files. You can achieve the same in Swift using class extensions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Vertex {
  var x : Float
  var y : Float

  func abs() -&amp;gt; Float {
    return sqrt(x*x + y*y)
  }
}

var v = Vertex(x:3, y:4)
println(v.abs())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However in Swift it would be more idiomatic to treat the length of a vertex as a calculated property. To do that the code becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Vertex {
  var x : Float
  var y : Float

  var abs : Float {
    return sqrt(x*x + y*y)
  }
}

var v = Vertex(x:3, y:4)
println(v.abs) // Looks like member variable access
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;Swift Protocols and Go Interfaces&lt;/h3&gt;

&lt;p&gt;Lack of classes does of course not mean that Go doesn&amp;rsquo;t support polymorphism. It does that using &lt;em&gt;interfaces&lt;/em&gt; which are quite similar to Swift &lt;em&gt;protocols&lt;/em&gt;. We don&amp;rsquo;t have to explicitly define that a struct implements an interface in Go, so if we define a interface like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Abser interface {
    Abs() float64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can automatically use &lt;code&gt;Vertex&lt;/code&gt; with it since it has a &lt;code&gt;Abs()&lt;/code&gt; method even if &lt;code&gt;Vertex&lt;/code&gt; came from a third party library we didn&amp;rsquo;t own and couldn&amp;rsquo;t modify.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    var a Abser
    v := Vertex{3, 4}
    a = v

    fmt.Println(a.Abs()) // displays 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though Swift does not allow classes or struct to implicitly implement a protocol like Go, it does still allow us to make third party classes and struct implement protocols they were never designed for. If we write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Abser { 
  var abs : Float { get }
}

var v : Abser = Vertex(x:3, y:4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will get the error&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;type &amp;lsquo;Vertex&amp;rsquo; does not conform to protocol &amp;lsquo;Abser&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we can&amp;rsquo;t do like Go, but we can tell Swift that &lt;code&gt;Vertex&lt;/code&gt; implements &lt;code&gt;Abser&lt;/code&gt; using a class extension (or perhaps we should call it struct extension in this case). Here is an excerpt from a Swift REPL session demonstrating that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 13&amp;gt; extension Vertex : Abser { 
 14. }    
 15&amp;gt; var v : Abser = Vertex(x:3, y:4) 
v: Vertex = {
  x = 3
  y = 4
}
 16&amp;gt; v.abs
$R0: Float = 5
 17&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If our &lt;code&gt;Vertex&lt;/code&gt; class had not already implemented &lt;code&gt;abs&lt;/code&gt; we could have added it with the class extension:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Vertex : Abser {
    var abs : Float {
      return sqrt(x*x + y*y)
    }    
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Go and Swift have a number of superficial similarities. So you can write code that looks almost identical and does the same thing but the way it works under the hood might be radically different. E.g. using pointers in Go and inout variables in Swift often looks almost identical but works very different.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift is Kotlin</title>
      <link>http://translusion.github.com/posts/swift-is-kotlin/</link>
      <pubDate>Thu, 05 Jun 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/swift-is-kotlin/</guid>
      <description>

&lt;p&gt;Around the internet people are saying Apple&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; looks like C#, JavaScript etc. This of course is just in the most superficial manner. E.g. both JavaScript and &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; has the &lt;code&gt;var&lt;/code&gt; keyword. But it means completely different things since &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; is statically typed and JavaScript is not.&lt;/p&gt;

&lt;p&gt;Anyway being generally curious about programming languages I could see similarities in &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; with &lt;a href=&#34;http://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt;, &lt;a href=&#34;http://golang.org&#34;&gt;Go&lt;/a&gt;, Scala and Ruby. However all these languages differ from Swift in quite a number of ways.&lt;/p&gt;

&lt;p&gt;But if you actually really want find a language that is close to &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt;, I don&amp;rsquo;t know of anything closer than &lt;a href=&#34;http://kotlin.jetbrains.org&#34;&gt;Kotlin&lt;/a&gt; developed by JetBrains. They both seem to have many of the same goals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Both want to integrate very well with their respective platform. Kotlin with Java and Swift with Objective-C. Unlike Scala which seems more focused on the idea of briding OO and functional programming.&lt;/li&gt;
&lt;li&gt;IDE support seems important. JetBrains want a language that works well with their IDE. Apple wants something that works well with xCode. Great tools is created in lockstep like e.g. Swift Playground. Rust and Scala e.g. are not heavily tool focused.&lt;/li&gt;
&lt;li&gt;Simplicity and familiarity are important goals. There are more sofisticated languages out there than &lt;a href=&#34;http://kotlin.jetbrains.org&#34;&gt;Kotlin&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; such as Scala, Rust and Haskell. But learning these languages fully requires a lot more effort.&lt;/li&gt;
&lt;li&gt;Functional programming is used as a way to enhance the language were it makes sense but it isn&amp;rsquo;t any central goal like in e.g. Clojure and Scala.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Feature and Syntax similarities&lt;/h2&gt;

&lt;p&gt;Both place type information after the name of the identifier unlike C/C++, C# and Java. This is also similar to Go, Rust, Pascal etc. Kotlin:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun sum(a : Int, b : Int) : Int { 
  return a + b 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sum(a : Int, b : Int) -&amp;gt; Int { 
  return a + b 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Syntax for ranges and for loops is similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (index in 1...5) {
    println(&amp;quot;$(index) times 5 is $(index * 5)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 1...5 {
    println(&amp;quot;\(index) times 5 is \(index * 5)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Pattern matching&lt;/h3&gt;

&lt;p&gt;Both do pattern matching in a smiliar manner, although different keywords is used. In Kotlin you write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;when (count) {
in 0 -&amp;gt;
    naturalCount = &amp;quot;no&amp;quot;
in 1...3 -&amp;gt;
    naturalCount = &amp;quot;a few&amp;quot;
in 4...9 -&amp;gt;
    naturalCount = &amp;quot;several&amp;quot;
in 10...99 -&amp;gt;
    naturalCount = &amp;quot;tens of&amp;quot;
in 100...999 -&amp;gt;
    naturalCount = &amp;quot;hundreds of&amp;quot;
in 1000...999_999 -&amp;gt;
    naturalCount = &amp;quot;thousands of&amp;quot;
else -&amp;gt;
    naturalCount = &amp;quot;millions and millions of&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note this is slightly wrong since I don&amp;rsquo;t believe Kotlin support &lt;code&gt;...&lt;/code&gt;. Just &lt;code&gt;..&lt;/code&gt;. But it isn&amp;rsquo;t that important with respect to showing the similarities and different between the pattern matching syntax.
Which in Swift turns into:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;when (count) {
c 0:
    naturalCount = &amp;quot;no&amp;quot;
case 1...3:
    naturalCount = &amp;quot;a few&amp;quot;
case 4...9:
    naturalCount = &amp;quot;several&amp;quot;
case 10...99:
    naturalCount = &amp;quot;tens of&amp;quot;
case 100...999:
    naturalCount = &amp;quot;hundreds of&amp;quot;
case 1000...999_999:
    naturalCount = &amp;quot;thousands of&amp;quot;
default:
    naturalCount = &amp;quot;millions and millions of&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Type casting&lt;/h3&gt;

&lt;p&gt;Even type casting looks and behaves in the same way, and the both have Option types to avoid null pointer exceptions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val x : String = y as String   // unsafe case. May throw exception.
val x : String? = y as? String // safe cast. Nil if not working
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x : String = y as String
let x : String? = y as? String
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;Enum types&lt;/h3&gt;

&lt;p&gt;Enumerations are quite different. They have some overlapping functionality. Both allow you to do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum class Direction { 
  NORTH 
  SOUTH 
  WEST 
  EAST 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum  Direction { 
  case NORTH, SOUTH, WEST, EAST 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But for more advance case Kotlin and Swift enums look quite different. I don&amp;rsquo;t understand either of them well enough to reason whether they actually represent the same thing deep down or if they are fundamentally different although I lean towards the latter. In Kotlin you can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum class Color(val rgb : Int) { 
  RED : Color(0xFF0000) 
  GREEN : Color(0x00FF00) 
  BLUE : Color(0x0000FF) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift my impression is that enums are not really objects in the normal sense. I believe technically they are called a sum type, which is also called a variant in some languages. You can reproduce the Kotlin example in a bit clunky way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Color {
    var red : Int
    var green : Int
    var blue : Int
}

enum ColorEnum {
    case RED, GREEN, BLUE
    var value : Color {
        switch self {
        case .RED:
             return Color(red: 1, green: 0, blue: 0)
        case .BLUE:
            return Color(red: 0, green: 0, blue: 1)
        case .GREEN:
            return Color(red: 0, green: 1, blue: 0)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I believe the more appropriate Swift way of doing it is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum  Color { 
  RED  (0xFF, 0x00, 0x00) 
  GREEN(0x00, 0xFF, 0x00) 
  BLUE (0x00, 0x00, 0xFF) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which works better for pattern matching in &lt;code&gt;switch-case&lt;/code&gt; statements. The advantage of the Swift approach is that it allows us to define variants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum ServerResponse {
  case Result(String, String)
  case Error(String)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can easily define results from functions which are either a value or error object but which the user is forced to extract with pattern matching using &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch fetchSunriseAndSunsetTimes() {
case let .Result(sunrise, sunset):
    let serverResponse = &amp;quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&amp;quot;
case let .Error(error):
    let serverResponse = &amp;quot;Failure...  \(error)&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I am not going to go through every feature, but it is clear when you look at how the languages work that there are a lot of similarities. In the regard that they are different I believe that is born out of the limitations set by each respective platform JVM or Objective-C runtime. Swift likely chose a more sofisticated enum type system with sum types to deal with the fact that exceptions can not easily be provided in a non GC language with Cocoa not being exception safe. I know there isn&amp;rsquo;t an obvious connection here but I believe enum types will be used for building an error handling system in the future for Apple API&amp;rsquo;s. Kotlin is more traditional in supporting exceptions which already works quite well on the JVM.&lt;/p&gt;

&lt;p&gt;Swift also needed away to deal with the peculiar naming of method in iOS where each argument has a name. Cocoa programming is also frequently uses plain C structs for things such as points, rectangles etc. Thus this is explicitly supported in Swift as value types. Java has had no support for this traditionally and thus it is probably harder to get value types to interact with Java API&amp;rsquo;s. Hence Kotlin has omitted value types.&lt;/p&gt;

&lt;p&gt;One advantage I can see from an iOS developers point of view is that I ocassionally work on Android development and if Kotlin is well supported on Android then it will make switching between iOS and Android development a smaller overhead languagewise. iOS and Android APIs are of course quite different but it might be possible to write model objects which are quite similar. Perhaps one can create tools which translate between Swift and Kotlin code as long as one stay with a common subset of functionality. The main problem with writing library code which could be shared is that a Swift API will not use exceptions for error handling but likely enum types. Kotlin APIs will likely rely on exceptions. So it is not possible to write shared functionality without sacrificing benefits on one of the platforms.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why the US can&#39;t teach the world</title>
      <link>http://translusion.github.com/posts/america-cant-teach-the-world/</link>
      <pubDate>Wed, 04 Jun 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/america-cant-teach-the-world/</guid>
      <description>

&lt;p&gt;While the US isn&amp;rsquo;t the richest country in the world in per capita GDP, it is by far the richest large country. It can boast of impressive results in science and innovation. Does that mean that anyone whishing to obtain similar levels of prosperity have to follow the American model for economic system and organization of society? My short answer is &amp;ldquo;no&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The US is an outlier which has too many advantages not related to the organization of its economy or society. Advantages which can not be replicated anywhere else in the world. The US has enjoyed close to 150 years without any destructive wars on its land. Much of the rest of the advance world has suffered multiple destructive wars settings back the countries decades. America also enjoys an abundance of natural resources and huge amounts of fertile land available to each citizen. Agricultural land may not be that important today, but 150 years ago when America started surpassing other wealthy nations this was a large benefit. With so much cheap and fertile land American&amp;rsquo;s could afford to waste land in order to safe labour, thus greatly increasing productivity in a way unavailable to the rest of the world. When industrialization started America could benefit from large coal reserves, water power. Later the economy could be fueled by large reserves of oil. Other advance nations usually did not have these resources available within their own borders in large quantities except coal.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;The problem with comparing the US to Europe or Japan&lt;/h2&gt;

&lt;p&gt;Even if we disregarded these benefits or resources, absence of war, large quantities of cheap land etc, there are other factors which make comparisons deceiving. Europeans have different preferences than Americans. They prefer leisure over money. Thus a large part of the difference in GDP numbers between the US and European states is due to Americans working far more hours. American GDP growth numbers often look impressive. However the American population increases much faster than the European and Japanese e.g. In terms of GDP growth per capita Japan has actually outperformed the US for the last decade, since they have a shrinking population and will actually obtain per capita growth with much lower overal GDP growth.&lt;/p&gt;

&lt;p&gt;And then there is the problem calculating and comparing GDP numbers. Finding the GDP is difficult by itself. Adjusting GDP at PPP might be even more difficult. Consumption patterns and prices are quite different between America, Europe and Japan. Europeans often spend more money on traveling than Japanese and Americans. American&amp;rsquo;s seem more conserned with quantity of stuff than quality than Japanese and Europeans. That is likely a natural result of having much less space. Europeans and especially Japanese can&amp;rsquo;t accumulate a lot of stuff in their house because they don&amp;rsquo;t have the space. Italians might buy fewer but more expensive clothes than Americans. Likewise American restaurants seem very eager to point out the amount of food you get.&lt;/p&gt;

&lt;p&gt;If you look at wealth indicators such as average house size, number of home  appliances, TVs etc American&amp;rsquo;s will clearly come out on top. The problem with such comparisons is that they don&amp;rsquo;t offer any lessons to the rest of the world with respect to the possible superiority of American economic model. If American society was completely replicated in Japan, then houses and number of appliances would not magically increase to American levels. There is just not enough space in Japan. Houses would be much more expensive regardless of economic system. This is a matter of geography rather than economic model. If you live on tiny space you are not going to fill your appartment with 4 TVs as might be fairly common in the US, so house size affects many other aspects of life.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;What can be compared&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t think it is possible to make comparison over very short term or comparison of absolute numbers because the potential in each country or region is tied to so many factors outside of political control, such as geography natural occurence of resources etc. However I do think one can compare trends. If one country stops growing while another starts a growth acceleraton after policy changes then it is natural to compare the effectiveness of each of these policies. Likewise it should be possible to compare health care. Living in a country with a lot of space or little space should not affect your health to a large degree.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why American states cannot be compared to European countries</title>
      <link>http://translusion.github.com/posts/europe-is-not-america/</link>
      <pubDate>Tue, 03 Jun 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/europe-is-not-america/</guid>
      <description>

&lt;p&gt;It is populare with peeing contests between America and Europe either in terms of GDP numbers, level of development, education, crime and what not. Of course regardless of how entertaining these sort of comparisons are, they are essentially apple to oranges comparisons. Europeans might score points by pointing to a number of of smaller European countries with very favorable statistics in a number of areas such as unemployment, human development index, crime rates, GDP etc. The American retort would be that these countries are too small to make for a meaningful comparison and that the whole of America should be compared to the whole of Europe. The idea is that variations among American states is quite large just like variations between European countries. Thus American states could be compared to European countries.&lt;/p&gt;

&lt;p&gt;Except this is a completely flawed analogy. American states operate under largely the same laws and regulations. They are inhabited by people with similar values and habits. All accross America people speak almost the same. The borders are completely porus and people move frequently from one state to another. It could not be more opposite in Europe. There are vast variations in laws, values habits and language spoken. Even within individual countries in Europe variations are frequently larger than across the whole of the US. In many countries different regions people speak quite different languages or dialects and have different traditions and customs. Belgium is essentially two different countries a French speaking Walonia and dutch speaking Flandern. Likewise Switzerland is like an amalgation of many small countries with different languages and laws.&lt;/p&gt;

&lt;p&gt;To speak of a European system is thus pointless. Comparing the whole of Europe to the US, makes no more sense than comparing the combination of Northern Europe and Northern States  with the combination of Southern States and Souther Europe. &amp;ldquo;Look how poor the south is doing. They have lower GDP than the North. They need to change their policy and laws!&amp;rdquo; It should be obvious to anybody that such a comparison in meaningless. Yet people seem to think that it makes sense when it applies to the whole of Europe. Greek society is no more similar to Norwegian society than New York.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Why can&amp;rsquo;t you compare a small country to a large?&lt;/h1&gt;

&lt;p&gt;This is frequently stated without much explanation. Lets look at it in more detail. Obviously a country of 1 can&amp;rsquo;t be compared to one with 1 million. One billionaire might move there and skew the results. Likewise very small countries like Luxemburg might create a tax heaven and have all rich people and banks move there and thus inflate GDP. Obviously such a tatic can&amp;rsquo;t be replicate at any scale. There can only be that much banking in the world. Kuwait is filthy rich because they have a tiny population relative to their vast oil reserves which may be extracted at a very low price. This policy can&amp;rsquo;t be replacated at a large scale to great prosperity either.&lt;/p&gt;

&lt;p&gt;My point is that I believe to a certain degree small and large countries can be compared as long as the wealth of the small country isn&amp;rsquo;t caused by a sort of anomaly which can&amp;rsquo;t be replicated by larger countries or areas. Hong Kong and Singapore are not rich due to banking or oil but they are also atypical, by both serving as hub into much larger countries. Also we can&amp;rsquo;t turn every country into cities. But I would argue that there are successfull small European countries which could scale. There is really nothing odd about the propsperity of Nordic countries, Switzerland, the Netherlands etc. You might argue that Switzerland has an artificially inflated economy due to its large banking sector. However with 8 million people this effect greately reduced compared to Luxembourghs population of 0.5 million. Norway has oil and gas but is not as atypical as gulf states which derive 80% of their income from oil easily and cheaply extracted, while Norway is the other way around where the non-oil economy contributes to 80% of the GDP. Oil extraction in Norway is also expensive and technologically challenging. For Sweden, Denmark and Netherland e.g. I can&amp;rsquo;t think of anything atypical. They are not abound with any valuable resources, have inflated banking sectors or are city states serving as hubs for industry in a much larger area. Thus I don&amp;rsquo;t see any problem comparing these states to the whole of the US or individual states which are not atypical. E.g. New York serving as the finance hub for 300 million people is an anomaly. Their success can not be scaled and replicated across the rest of the country. Maryland benefits from proximity to the capital and all the federal jobs and largesse that follows.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Munching Data with Julia</title>
      <link>http://translusion.github.com/posts/munchingdata-julia/</link>
      <pubDate>Sun, 11 May 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/munchingdata-julia/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve recently performed a survey at my work using &lt;a href=&#34;http://www.google.com/google-d-s/createforms.html&#34;&gt;Google form&lt;/a&gt;, unfortunatle the data wasn&amp;rsquo;t usable right out of the box, because it my company allowed people to register an answer multiple times, but one person should just have one vote.&lt;/p&gt;

&lt;p&gt;I chose to clean the data with &lt;a href=&#34;http://julialang.org&#34;&gt;the Julia programming language&lt;/a&gt;, which might not be the best choice for this sort of thing. Not because julia isn&amp;rsquo;t suited but because SQL, sed or awk might do such a specialized and simple task faster. Unfortunately I am crappy at all 3. The data looked like this (anonymized):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5/8/2014 10:32:14   spam@mycompany.no   Bonus   2,5%   40%       4,42%
5/8/2014 10:35:03   bar@mycompany.no    Higher salary     2,9%   37,5%    3,9%
5/8/2014 10:41:10   spam@mycompany.no   Bonus   2,5%   40%       4,42%
5/8/2014 10:45:10   foo@mycompany.no    Higher salary    2,9%   37,5%    3,9%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I exported it with tab as separator since some of the columns used comma in the text. In Europe we often use comma instead of dot for separating decimals.&lt;/p&gt;

&lt;p&gt;So the task was to eliminate to double or more votes, keeping only the most recent choice. So e.g. in our example &lt;em&gt;spam&lt;/em&gt; voted twice. So the 1st line needs to be elimenated and the 3rd kept.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;Read the data&lt;/h3&gt;

&lt;p&gt;First we read in our data. Indicating that data is separated with tab and that first line is a header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(ourdata, header) = readdlm(&amp;quot;result.tsv&amp;quot;, &#39;\t&#39;, has_header=true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives us a 2D array (matrix) which sounds neat. Well it is quite neat in a lot of ways. I can ask for e.g. the whole second column containing the email of the respondents with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ourdata[:,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I instead wanted the 3rd row I could do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ourdata[3, :]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is &lt;strong&gt;NOT neat&lt;/strong&gt; about it compared to the regular arrays within arrays found in languages such a python and ruby is that you can&amp;rsquo;t process this with a &lt;code&gt;foreach&lt;/code&gt; type of construct. Like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for row in ourdata
   dostuff(row)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;row&lt;/code&gt; will in this case just be a substring and not an actual array object.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Find unique rows&lt;/h3&gt;

&lt;p&gt;Instead you have to iterate by index:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;byname = Dict{String, Any}()
for i in 1:size(ourdata,1)
    byname[ourdata[i, 2]] = ourdata[i, :]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we are doing here is to record each line on email. Thus only the last line for a given email get stored. Previous duplicated gets discareded. Just what we want. &lt;code&gt;size(ourdata, 1)&lt;/code&gt; gives us the number of rows. &lt;code&gt;size(ourdata, 2)&lt;/code&gt; would have given number of columns. &lt;code&gt;length(ourdata)&lt;/code&gt; or &lt;code&gt;size(ourdata)&lt;/code&gt; would not have worked because this is not an array of arrays. So your usual python or ruby reflexes don&amp;rsquo;t apply.&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Count each line matching a predicate&lt;/h3&gt;

&lt;p&gt;So to check how many of our respondents wanted higher bonus we do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count(values(byname)) do row
    row[3] == &amp;quot;Bonus   2,5%   40%       4,42%&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And to get those who want higher salary:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count(values(byname)) do row
    row[3] == &amp;quot;Higher salary    2,9%   37,5%    3,9%&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;Working with Dates in Julia&lt;/h3&gt;

&lt;p&gt;When I first started looking at this problem, I thought I needed to work with dates, which wasn&amp;rsquo;t necessary because the data was already sorted by date and time, but if it wasn&amp;rsquo;t you need to get hold of the julia &lt;a href=&#34;https://github.com/karbarcca/Datetime.jl&#34;&gt;datetime package&lt;/a&gt;. There isn&amp;rsquo;t anything builtin to deal with dates. Here are some practical examples on how to use it. Our data had date and time like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5/8/2014 0:16:03
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which isn&amp;rsquo;t the format the package deals with date and time. So here are some tricks for how to convert:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(d, t) = split(&amp;quot;5/8/2014 0:16:03&amp;quot;) # Put date in d, and time t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then turn this into a formate our date creation function &lt;code&gt;date&lt;/code&gt; wants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;date(reverse(map(int, split(d, &#39;/&#39;)))...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;Iteratively creating code in the Julia REPL&lt;/h3&gt;

&lt;p&gt;That was a &lt;em&gt;mouthfull&lt;/em&gt;. Usually when writing lines like this I develop them interactively by starting with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; split(d, &#39;/&#39;)
3-element Array{String,1}:
 &amp;quot;5&amp;quot;   
 &amp;quot;8&amp;quot;   
 &amp;quot;2014&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks like what I wanted, but the data is string and I need integers so I:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hit arrow up button to get back &lt;code&gt;split&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ctrl+A to go to start of line and write &lt;code&gt;map(int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ctrl+E to get to end of line and close it with &lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This gives me the next line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; map(int, split(d, &#39;/&#39;))
3-element Array{Int64,1}:
    5
    8
 2014
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks good, but not in reverse order compared to what &lt;code&gt;date&lt;/code&gt; wants. So we do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; reverse(map(int, split(d, &#39;/&#39;)))
3-element Array{Int64,1}:
 2014
    8
    5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay so we are good, except &lt;code&gt;date&lt;/code&gt; doesn&amp;rsquo;t take an array as argument. So we need to explode our array to function arguments with the &lt;code&gt;...&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Web Development with Rails</title>
      <link>http://translusion.github.com/posts/learning-rails/</link>
      <pubDate>Mon, 05 May 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/learning-rails/</guid>
      <description>

&lt;p&gt;Here are some of my notes from learning rails. I am following the course &lt;a href=&#34;https://class.coursera.org/webapplications-001&#34;&gt;Web Application Architectures&lt;/a&gt; at &lt;a href=&#34;https://www.coursera.org&#34;&gt;Coursera&lt;/a&gt;. This is seen from perspective of someone used to more desktop applications. I used Ruby as a scripting language for writing small unix tools in the past, but I am not considering myself very up to date.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Setup Project&lt;/h1&gt;

&lt;p&gt;Have rails autogenerate a bunch of files for a project:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails new myproject
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seems to be the way to create a new model class with corresponding table in database:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails generate scaffold comment post_id:integer body:text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will to a whole bunch of things. A &lt;strong&gt;scaffold&lt;/strong&gt; from what I can understand is a collection of related:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Database table&lt;/li&gt;
&lt;li&gt;Model class&lt;/li&gt;
&lt;li&gt;Controller class&lt;/li&gt;
&lt;li&gt;HTML template files representing view&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So I will get a table for my comment, a definition of a model class. Actually the model class won&amp;rsquo;t contain anything, but rails creates methods on it at runtime for me to access variables. That is part of &lt;code&gt;ActiveRecord&lt;/code&gt; from what I understand. One can call methods such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a_comment     = Comment.new
all_comments  = Comment.all
first_comment = Comment.first
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and this will cause SQL statements to be formed fetching the data out from the underlying table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Comment.first
    Comment Load (0.1ms)  
    SELECT  &amp;quot;comments&amp;quot;.* FROM &amp;quot;comments&amp;quot;   
    ORDER BY &amp;quot;comments&amp;quot;.&amp;quot;id&amp;quot; ASC LIMIT 1
    =&amp;gt; #&amp;lt;Comment 
        id: 2, 
        post_id: 1, 
        body: &amp;quot;This is my first comment&amp;quot;, 
        created_at: &amp;quot;2014-05-05 10:15:52&amp;quot;, 
        updated_at: &amp;quot;2014-05-05 10:15:52&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve taken the liberty to format the output for readability. The Controller objects are apparently supposed to be mediators like in Cocoa, but it seems to be used a bit different. They seem to provide the actions the user perform on an object from the user interface. We can use the &lt;code&gt;rake routes&lt;/code&gt; to find out what REST services are provided. Or probably this isn&amp;rsquo;t called REST but is just a bunch of URLs for performing different HTTP actions. But it seems to correspond to what is created in the controllers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake routes
       Prefix Verb   URI Pattern                                 Controller#Action
     comments GET    /comments(.:format)                         comments#index
              POST   /comments(.:format)                         comments#create
  new_comment GET    /comments/new(.:format)                     comments#new
 edit_comment GET    /comments/:id/edit(.:format)                comments#edit
      comment GET    /comments/:id(.:format)                     comments#show
              PATCH  /comments/:id(.:format)                     comments#update
              PUT    /comments/:id(.:format)                     comments#update
              DELETE /comments/:id(.:format)                     comments#destroy
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Inspecting and Debugging&lt;/h1&gt;

&lt;p&gt;You can interact with your whole rails app from the command line. You don&amp;rsquo;t need a browser running just run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can go ahead and call methods such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a_comment     = Comment.new
all_comments  = Comment.all
first_comment = Comment.first
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mentioned earlier. I recommend using &lt;code&gt;pry&lt;/code&gt; it is much better than the standard &lt;code&gt;irb&lt;/code&gt; which is a bit antiquated. Install with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install pry pry-doc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can run the rails console with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pry -r ./config/environment.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pry&lt;/code&gt; let you do some neat things like &lt;code&gt;cd&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; into classes or objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; cd 42.6
1&amp;gt; round
=&amp;gt; 42
1&amp;gt; exit
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great way to drill down into your objects and inspect them.  &lt;code&gt;pry&lt;/code&gt; wans&amp;rsquo;t covered in the course I just found that online.&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Databases and SQL&lt;/h1&gt;

&lt;p&gt;You don&amp;rsquo;t setup the tables in the database yourself directly. Instead rails will generate a &lt;code&gt;schema.rb&lt;/code&gt; file. Looking like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ActiveRecord::Schema.define(version: 20140502112529) do

  create_table &amp;quot;comments&amp;quot;, force: true do |t|
    t.integer  &amp;quot;post_id&amp;quot;
    t.text     &amp;quot;body&amp;quot;
    t.datetime &amp;quot;created_at&amp;quot;
    t.datetime &amp;quot;updated_at&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This ruby code will generate all the necessary SQL statements to actually create the database.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deterministic Password Generator</title>
      <link>http://translusion.github.com/posts/dulgt-intro/</link>
      <pubDate>Sun, 04 May 2014 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/dulgt-intro/</guid>
      <description>

&lt;p&gt;The heartbleed exploit made  me thing of my own way of keeping passwords which relies on 1Password. What was painfull with 1Password was having to regenerate every single password I have over again. That is a lot of work. The second problem because all my passwords are too hard to remember, I am screwed if I ever lose my encrypted database of passwords. So I also make paper copies, but they have to be made secure as well, so they can not be used directly in their paper form.&lt;/p&gt;

&lt;p&gt;So this has left me with desirng a better solution. Deterministic password generators seem attractive, but there is no one program that works exactly how I want it to work. But there are a of neat ideas out there.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Existing Solutions&lt;/h1&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Enigma&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/us/app/enigma/id527555438?mt=12&#34;&gt;Enigma&lt;/a&gt; looks pretty cool, but they had horrible customer support and have trouble with basic english. So not the kind of people I want to entrust with generating my passwords. Should I get a problem with their solution I need crystal clear communication. Also any solution should be open source, so you know exactly how the passwords are made and which makes it possible for you to roll your own solution should the company go belly up.&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Generator without Single Point of failure&lt;/h3&gt;

&lt;p&gt;John Metta has some interesting &lt;a href=&#34;http://mettadore.com/ruby/secure-password-generator-as-manager-without-single-point-failure/&#34;&gt;ideas&lt;/a&gt; on how to do this, but he doesn&amp;rsquo;t have a product yet that he can vouch for. Anyway I&amp;rsquo;ll keep my eye on his progress.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;Pronouncable Passwords&lt;/h3&gt;

&lt;p&gt;I kind of like pronounable passwords because they are far easier to remember. &lt;a href=&#34;http://passkool.sourceforge.net&#34;&gt;PassKool&lt;/a&gt; is a python script which uses this approach. However I have to check how safe this is. Making them pronounable of course reduces the search space for a hacker. &lt;a href=&#34;http://www.iusmentis.com/security/passphrasefaq/&#34;&gt;Passphrase FAQ&lt;/a&gt; might be the place to learn how to do it.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;What I want in a Solution&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Open source&lt;/li&gt;
&lt;li&gt;Based on well established standards which are can be verified to be safe without being a crypto expert.&lt;/li&gt;
&lt;li&gt;Should be very easy to recreate the code for generating the passwords, should the original program get lost.&lt;/li&gt;
&lt;li&gt;On multiple platforms. I want the tool accessible from my phone, desktop, browser and command line.&lt;/li&gt;
&lt;li&gt;Stores a list of sites or places I have made passwords for and settings used, so I don&amp;rsquo;t forget that I actually have a password already for said site. I actually often forget that.&lt;/li&gt;
&lt;li&gt;Should be easy to use. So I should mostly have to write a really easy password.&lt;/li&gt;
&lt;li&gt;Paper backups. Should be easy to print out a piece of paper from the app containing key information. E.g. by using QR codes so it is really easy to restore a backup.&lt;/li&gt;
&lt;li&gt;Should be secure, so that hackers can&amp;rsquo;t easily break my master password once they get hold of one of my passwords.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(6) and (8) are obviously at odds with each other. My approach here would be to rely on certain assumptions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An attacker will most likely attack me online.&lt;/li&gt;
&lt;li&gt;He will not break into my house.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So my current idea for a solution relies on the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;One simple password whic his what is mostly asked of me.&lt;/li&gt;
&lt;li&gt;A hard to guess completely random component which I can not hope to remember. This will be stored on paper and will remain in memory for a limited amount of time. So occasionally it will need to be brought back using a QR code scanner e.g. Or if no camera is present with manual typing.&lt;/li&gt;
&lt;li&gt;The on paper is encrypted with my simple password so that should somebody accidentally get hold of my paper backup then can&amp;rsquo;t use it unless they know something about hacking.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The security of the individual points can be tweaked. The assumption here is that ultimately nothing is completely secure. It is all about making it really inconveient for the hacker. If you don&amp;rsquo;t have important secrets or are not an important or wealthy person, we can assume that less security is needed, so that people may e.g. chose themselves whether the paper data should be encrypted and e.g. for how long the hard passwords should remain valid in memory. If your security needs are lower you could let the password stay indefintitly in memory. You could even store it permanently on disk.&lt;/p&gt;

&lt;p&gt;There should be a lot of options to make sure the generator works for everyones needs.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Technologies I should probably use&lt;/h2&gt;

&lt;p&gt;I should probably use &lt;a href=&#34;http://en.wikipedia.org/wiki/Hash-based_message_authentication_code&#34;&gt;HMAC&lt;/a&gt;(Hash-based message authentication code) because that is designed to hash using a secret key. Normally we hash like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digest = hash(message, salt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With HMAC it is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digest = hash(message, salt, secret)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is better than doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digest = hash(message || secret, salt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;||&lt;/code&gt; means concatenate. Apparently this is potentially exploitable because you can create the hash without knowing all of the separate parts.&lt;/p&gt;

&lt;p&gt;But I don&amp;rsquo;t think HMAC is specifically design for generating passwords. So using &lt;code&gt;bcrypt&lt;/code&gt; or &lt;code&gt;scrypt&lt;/code&gt; might be better. Potentially I could combine them with HMAC in some way.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/pkg/crypto/hmac/&#34;&gt;HMAC in standard Go package&lt;/a&gt; Takes as argument a hash function, key and message.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/go/source/browse/scrypt/scrypt.go?repo=crypto&#34;&gt;scrypt for Go&lt;/a&gt; It uses a password, salt, some parameter which specify CPU and memory usage to slow it down. We could perhaps input generated key from scrypt into HMAC&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/go/source/browse/?repo=crypto&#34;&gt;All crypto functions you might need in Go&lt;/a&gt; This contains bcrypt, blowfish, SHA3, PBKDF2 etc.&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;List of existing solutions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.xanthir.com/password/&#34;&gt;xanthir.com&lt;/a&gt; Configure length, allowed characters. Poor security with SHA-1 hash&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://plevyak.com/dpg.html&#34;&gt;plevyak.com&lt;/a&gt; Skein-512 based. Looks promising with use of option distinguishing Information&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://supergenpass.com&#34;&gt;SuperGenPass&lt;/a&gt; Made to drop down from bookmarks and work on mobile homescreen. Easy to use but doesn&amp;rsquo;t seem to be based on generally accepted good practice. In source code it looks like MD5 or SHA1 is used with just 10 iterators. That seems like bad choices. Should be far more iterations and with a better hash function such as SHA2 or SHA3 or bcrypt.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.pwdhash.com&#34;&gt;Standford PwdHash&lt;/a&gt; Transparently converts a user password to a domain specific password. Is possibly using MD5 for hashing which is not desirably. Creator also reserves the right to change the tool.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fuktommy.com/genpasswd/&#34;&gt;Fuktommy genpasswd&lt;/a&gt; A very simple version using SHA-1. Easy to read code. No iterations (no stretching) so poor security.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://passhash.connorhd.co.uk&#34;&gt;PassHash&lt;/a&gt; Very simple. Uses SHA246-HMAC, but likely no iterations.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ctrlq.org/passwords/&#34;&gt;Secure Passwords&lt;/a&gt; Clean design using bcrypt. A bit too simple perhaps, but with good help instructions.&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Resources&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://crackstation.net/hashing-security.htm&#34;&gt;crackstation&lt;/a&gt; Great info on hashing. E.g. on why you shouldn&amp;rsquo;t invent your own wacky hashing solutions by combining existig ones. Correct use of salt etc.&lt;br&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debugging AVR projects</title>
      <link>http://translusion.github.com/posts/debugavrproject/</link>
      <pubDate>Sun, 24 Mar 2013 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/debugavrproject/</guid>
      <description>

&lt;p&gt;This is a distilation of my last weeks of experience building an AVR curcuit on a breadboard and prototype board and programming it in assembly. Look at one of my previous post to see how you get up to speed with the assembler, avrdude for transfering programs etc.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;Continuity Buzzer&lt;/h3&gt;

&lt;p&gt;When I wanted to check whether to points on my circuit were connected before I turned my multimeter on measuring resistance (power turned off of course). If it measured around 0 ohm I knew I had a connection. Only recently I got a much nicere multimeter and I discovered how much faster you can do this with a continuity buzzer. It works pretty much the same as my old approach. I can still see the resistance in ohms. However it also gives off a beep each time resistance is zero. I didn&amp;rsquo;t realize how usefull that was until I started checking my circuits for problems. You can just move your test probes along quickly without every moving your eyes away from the circuit and just listen for the buzz. I was surprised by how much faster I could check lots of lines on my circuit.&lt;/p&gt;

&lt;p&gt;On my prototype board were I just built a development board for 8 pin AVR microcontrollers (see previous post) I was often not sure if my soldering was good or if I had connected everything correctly. The board was a mess of cables so it was easy to forget connections which I did. With the continuity buzzer my approach was to first place one test probe on ground and then move the second one along every point of the circuit which is supposed to be connected to ground and listen for a beep. Then I repeat the same procedure for Vcc.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Printf type debugging on a Microcontroller&lt;/h3&gt;

&lt;p&gt;When developing software I would use one of my LEDs for debugging. So e.g. if I wrote a program where you could adjust the frequency of the blinking of the green LED, then I would use the yellow LED for debugging. I would write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sbi PINB, PB1 ;flip yellow LED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To flip the LED from on to off or off to on. Writing 1 to the input register, as opposed to the output register does that. I would move this line around in the program to make sure that I hit the appropriate section of code when I expected. A limiting factor is that you can not keep this line in a lot of places, because you can not distinguish between them. This is not as problematic as it sounds, since the programs you write on a ATtiny13 in assembly will probably be quit small. If you write larger programs I recommend using the Arudino instead or investing in a proper development board from ATMEL. I did all my development using TextMate 2.0 with an AVR assembly bundle. I then had a hotkey for building and one for uploading. It worked quite well.&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Clock signal mistakes&lt;/h3&gt;

&lt;p&gt;When creating the hardware, by far the mistake which cost me the most time was mixing up CLKI and SCK (pin 2 and 7) on the AVR. I thought I should use CLKI for the clock pin 3 on the ISP6 connector. Then nothing works and you get the same error message from avrdude as you would have gotten if no cable was connected. Actually avrdude gives the same error for almost anything it seems. Other than that most of my mistakes were in software.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;Messing up unsigned arithmetic&lt;/h3&gt;

&lt;p&gt;You really ought to get a grasp of unsigned aritmetic. Since you typically work with 8bit values you often have to use unsigned numbers to be able to have numbers in the range 0 to 255 and not just -128 to 127. When branching you should then not use instructions such as:
&lt;ul&gt;
    &lt;li&gt;&lt;span style=&#34;line-height:13px;&#34;&gt;BRLT (&lt;strong&gt;BR&lt;/strong&gt;anch if &lt;strong&gt;L&lt;/strong&gt;ower &lt;strong&gt;T&lt;/strong&gt;han)&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;BRGE (&lt;strong&gt;BR&lt;/strong&gt;anch if &lt;b&gt;G&lt;/b&gt;reater or&lt;b&gt; E&lt;/b&gt;qual)&lt;/li&gt;
    &lt;li&gt;BRMI (&lt;strong&gt;BR&lt;/strong&gt;anch if &lt;b&gt;MI&lt;/b&gt;nus)&lt;/li&gt;
&lt;/ul&gt;
These instructions will typically treat the numbers in the comparisons or arithmetic instructions preceding them as signed numbers with range -128 to 127. The problem with that is that if you write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ldi r16, 128
cpi r16, 127
brge r16Greatest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might expect this code to branch to &lt;em&gt;r16Greatest, &lt;/em&gt;since 128 &amp;gt; 127. But it wont because BRGE is treating the numbers as signed. Then 128 is -128, and -128 &amp;lt; 127, so there will be no branching.&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;Understanding timers&lt;/h3&gt;

&lt;p&gt;My second big misunderstanding was the timer/counter system. Register TCNT0 counts upwards constantly and you can use it as a sort of timer or to generate PWM signals on the output. One way of using it is to toggle an output pin OC0B (PB1) or OC0A (PB0) whenever I/O register TCNT0 is equal to I/O register OCR0B or OCR0A. You can configure this in one of the timer controll registers. So far so good. The problem arose when using something called CTC mode. When using CTC, the TCNT0 register will be reset to 0 each time TCNT0 equals OCR0A. The last part is the imporant. You can only use OCR0A for this purpose on ATtiny13. When TCNT0 equals OCR0B it will toggle the OC0B pin if you have enabled that but it will never reset TCNT0. There is no way of configuring that.&lt;/p&gt;

&lt;p&gt;The implication of that is also that you can not blink your LEDs at different frequency, but you may blink them out of phase, since OCR0B need not be the same as OCR0A. When I first set this up I did not understand this difference so I wrote a value into OCR0B thinking that would affect the frequency of LED blinking. I did not get any blinking at all. Just a steady light because OCR0A was 0, since it was never set. Thus when TCNT0 got reset it immediatly got the same values as OCR0A again. When turning on interrupts, this had the effect of making the interrupt only fire once.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Development board for 8 pin AVR microcontrollers</title>
      <link>http://translusion.github.com/posts/avrdevboard/</link>
      <pubDate>Sun, 24 Mar 2013 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/avrdevboard/</guid>
      <description>&lt;p&gt;I got a bunch of ATtiny13 AVR microcontroller chips because I tought it would be fun to see what you can do with a tiny 8 pin microcontroller. The thought first popped into my mind when I looked at a project for creating motor controller for an electric spinning wheel.&lt;/p&gt;

&lt;p&gt;The project used the same chip as in an arduino with an arduino bootloader. The ATmega328 is a lot more expensive than a ATtiny13. You can get a tiny for around 20 Kr at e.g. &lt;a title=&#34;electrokit&#34; href=&#34;http://www.electrokit.com&#34;&gt;electrokit&lt;/a&gt; in sweden.&lt;/p&gt;

&lt;p&gt;Lots of projects such as motor controllers with buttons or a dial for controlling speed does not need anything more than a tiny13, and a small program. My first problem however hooking up the circuit below to program one of my tiny13s, is that it is easy to connect the cables to the programmer wrong.&lt;/p&gt;

&lt;p&gt;&lt;caption id=&#34;&#34; align=&#34;alignnone&#34; width=&#34;650&#34;&gt;&lt;a href=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0648.jpg&#34;&gt;&lt;img id=&#34;i-179&#34; class=&#34; wp-image&#34; title=&#34;ATtiny13 development breadboard&#34; src=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0648.jpg?w=650&#34; alt=&#34;ATtiny13 development breadboard&#34; width=&#34;650&#34; height=&#34;365&#34; /&gt;&lt;/a&gt; Development board for AVR ATtiny13 microcontroller on breadboard, connected to a AVR-ISP500 programmer from Olimex. Pin 2 and 7 are connected to push buttons, which will pull the pins LOW when pushed (will connect to GND). Pin 6 and 5 drive a yellow and green LED through 2 transistors. The two transistors and 22K Ohm resistors are there to avoid interfering with the programmer, since it uses those pins for MISO and MOSI.&lt;/caption&gt;&lt;/p&gt;

&lt;p&gt;The example above is not too bad because I used colored wires with one female and one male end. Thus I could connect the female end directly to the output of the programmer and the male end into the breadboard. But if you have to connect into the connector of a ISP6 cable then it is easy to get the pin numbering wrong.&lt;/p&gt;

&lt;p&gt;So that is why I build the above curcuit first on a breadboard, tested it and then built it on the prototype board below.&lt;/p&gt;

&lt;p&gt;&lt;caption id=&#34;&#34; align=&#34;alignnone&#34; width=&#34;650&#34;&gt;&lt;a href=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0653.jpg&#34;&gt;&lt;img id=&#34;i-216&#34; class=&#34; wp-image&#34; title=&#34;ATtiny13 development board&#34; src=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0653.jpg?w=650&#34; alt=&#34;ATtiny13 development board&#34; width=&#34;650&#34; height=&#34;427&#34; /&gt;&lt;/a&gt; Pin 2 and 7 are connected to push buttons, which will pull the pins LOW when pushed (will connect to GND). Pin 6 and 5 drive a yellow and green LED through two 2N2222 transistors. Potentiometer is connected to pin 3. Red LED indicates that our LM7805 voltage regulator is delivering power. On the bottom right there is a ISP6 connector for in system programming.&lt;/caption&gt;&lt;/p&gt;

&lt;p&gt;It has a ISP6 connector (black 2x3 pins). With this there is only one way to connect the cable from your programmer, so it is very quick to connect your 8 pin AVR microcontroller to a programmer. A lot of devboards contains the bare minimum of components. I wanted to be able to test most of my ideas and programs directly on my development board without having the move the chip to another circuit to do actual work.&lt;/p&gt;

&lt;p&gt;So my development board has the following inputs and outputs which I believe I will typically be using for most projects:
&lt;ul&gt;
    &lt;li&gt;&lt;span style=&#34;line-height: 14px;&#34;&gt;2 outputs connected to a green and yellow LED. These are connect to pins which can do PWM, since I will need that for motor controller programs.&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;2 digital inputs connected to push buttons. Assume pullup resistor is enabled.&lt;/li&gt;
    &lt;li&gt;1 analog input connected to a potentiometer.&lt;/li&gt;
&lt;/ul&gt;
&lt;caption id=&#34;&#34; align=&#34;alignnone&#34; width=&#34;650&#34;&gt;&lt;a href=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/tiny13-programmer_bb.png&#34;&gt;&lt;img id=&#34;i-236&#34; class=&#34; wp-image&#34; title=&#34;Partlist for attiny13 devboard&#34; src=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/tiny13-programmer_bb.png?w=650&#34; alt=&#34;partlist&#34; width=&#34;650&#34; height=&#34;304&#34; /&gt;&lt;/a&gt; 10uF, 100uF capacitor handling 25V. 10K potentiometer. Two 2N2222 transistors. 3 push buttons (one for reset not shown). 3 regular LEDs as shown. 1 switch for power. LM7805 voltage regulator (+5V out). Restors as shown.&lt;/caption&gt;&lt;/p&gt;

&lt;p&gt;If figured I would to projects with blinking LEDs, dimmers or motor controllers. All that will require PWM. Hence pin 6 and 5 were selected for output.&lt;/p&gt;

&lt;p&gt;In the design it is worth nothing that the outputs of the AVR chip do not power the green and yellow LED directly. The reason for that is that pin 6 and 5 are used for in system programming, and are thus connected to our programmer.&lt;/p&gt;

&lt;p&gt;Connecting LEDs directly to these same pins as used by the programmer could interfere with its operation. &lt;a title=&#34;Atmel AVR042: AVR Hardware Design Considerations&#34; href=&#34;http://www.atmel.com/images/doc2521.pdf&#34;&gt;ATMELs datasheets&lt;/a&gt;(page 6) says you should put in a series resistor between the load and the AVR. 10K would be a good value. I put in 22K and a transistor so very little current or voltage drop will happen to drive the LEDs.&lt;/p&gt;

&lt;p&gt;I can program the AVR without any external power because the AVR-ISP500 programmer I use delivers power to the AVR through pin 2 of ISP6 connector. With the transistors I am also able to program it while external power is connected and the circuit is running. This makes development a lot faster, because I do not need to unplug anything to test the circuit, or plug in anythin to transfer an updated version of my program.&lt;/p&gt;

&lt;p&gt;Here is a very simple program I ran on it to make one of the LEDs blink. I will not explain the program here, because it is just something for you to try, to make sure it works.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .include &amp;quot;tn13def.inc&amp;quot;
  .def a = r16
  .org 0000
   rjmp Reset

Reset:
   ;define output
   sbi DDRB, PB0
   sbi DDRB, PB1
   cbi PORTB, PB0 ;turn off LED
   cbi PORTB, PB1

   ;set prescaler to divide clock freq by 1024. 
   ;each count is about 0.8ms at 1.2MHz
   ldi a, 1&amp;lt;&amp;lt;CS02 | 1&amp;lt;&amp;lt;CS00
   out TCCR0B, a

   ;set blink frequency
   ldi a, 250
   out OCR0A, a
   ldi a, 250
   out OCR0B, a

   ;set CTC mode (clear timer/counter on compare)
   ldi a, 1&amp;lt;&amp;lt;WGM01 | 1&amp;lt;&amp;lt;COM0B0 | 1&amp;lt;&amp;lt;COM0A0 
   out TCCR0A, a 
loop:
   nop
   rjmp loop
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AVR Assembly programming on Mac OS X</title>
      <link>http://translusion.github.com/posts/avrassembly/</link>
      <pubDate>Tue, 05 Mar 2013 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/avrassembly/</guid>
      <description>&lt;p&gt;When starting with out programming the &lt;a href=&#34;http://en.wikipedia.org/wiki/Atmel_AVR&#34;&gt;AVR&lt;/a&gt; microcontroller on OS X, you will probably start by using &lt;a href=&#34;http://www.obdev.at/products/crosspack/index.html&#34;&gt;CrossPack&lt;/a&gt;. However the problem with that is it doesn&amp;rsquo;t come with a compiler meant to be used directly by you. It is mainly there for the C compiler. &lt;a href=&#34;http://www.obdev.at/products/crosspack/index.html&#34;&gt;CrossPack&lt;/a&gt; installs the AVR GNU assembler &lt;strong&gt;avr-as&lt;/strong&gt; described &lt;a href=&#34;http://www.nongnu.org/avr-libc/user-manual/assembler.html&#34;&gt;here&lt;/a&gt;. The assembly files typically end with &lt;strong&gt;.S&lt;/strong&gt;. You can invoke it through gcc with e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;avr-gcc -Wall -Os -DF_CPU=8000000 -mmcu=attiny13 -x assembler-with-cpp -c ledflash.S
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will assemble the file &lt;em&gt;ledflash.S &lt;/em&gt;for the AVR microcontroller unit (MCU) ATtiny13. The problem with this assembler is that it does not use the same directives as the the official ATMEL  assembler. Most example code and tutorials you can find online is written according to the ATMEL assembler.&lt;/p&gt;

&lt;p&gt;Fortunatly if you look around you can find the open source &lt;a href=&#34;http://avra.sourceforge.net&#34;&gt;avra&lt;/a&gt; assembler. A problem when first googling is that an older assembler &lt;strong&gt;tavrasm&lt;/strong&gt; will more likely pop up first in your search. Ignore this one. It does not seem to be maintained.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://avra.sourceforge.net&#34;&gt;avra&lt;/a&gt; is newer and is very  easy to compile yourself. There are no dependencies. You just have to give a list of files to gcc or clang to compile it. To check that everything has been assembled correctly you can use the &lt;a title=&#34;vAVRdiasm&#34; href=&#34;https://github.com/vsergeev/vAVRdisasm&#34;&gt;vAVRdiasm&lt;/a&gt; to diassemble the .hex file and see that you get back something that looks like what you put in ;-)&lt;/p&gt;

&lt;p&gt;There is also a TextMate &lt;a title=&#34;avr-assembly bundle&#34; href=&#34;https://github.com/mherb/avr-assembly.tmbundle&#34;&gt;bundle avr-assembly&lt;/a&gt; which you can install which makes it possible to have syntax highlight for your AVR assemble programming.&lt;/p&gt;

&lt;p&gt;As a final note, be aware that you have to fiddle a little bit with all of this software. A lot of stuff did not work exactly as the manual said. It is usually just very minor adjustments to make it work. E.g. the TextMate bundle instructions gave the wrong path to bundles for TextMate2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with AVR programming</title>
      <link>http://translusion.github.com/posts/avr_without_arduino/</link>
      <pubDate>Fri, 01 Mar 2013 00:00:00 UTC</pubDate>
      <author>Erik Engheim</author>
      <guid>http://translusion.github.com/posts/avr_without_arduino/</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;After Arduino&lt;/h2&gt;

&lt;p&gt;So you tried Arduino programming. It is a great way to get introduced to Microcontrollers. But if you are actually an experienced programmer it doesn&amp;rsquo;t quite feel like the real thing. It is sort of like learning BASIC when you know there is this other thing real programmers use which is C.&lt;/p&gt;

&lt;p&gt;Arduino is built around the AVR microcontroller. It simplifies a lot by providing a USB port on the board itself and having a loaded program to load your program into the memory of the AVR microcontroller. If you want to program an AVR chip directly without having all the Arduino infrastructure, then you need a piece of hardware called a programmer and software such as AVRdude.&lt;/p&gt;

&lt;p&gt;The problem getting started with this is that the information related to it is scattered all around the internet. This is my attempt to collect it all in one guide.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;What  software to get&lt;/h3&gt;

&lt;p&gt;First get &lt;a title=&#34;CrossPack&#34; href=&#34;http://www.obdev.at/products/crosspack/index.html&#34;&gt;CrossPack&lt;/a&gt;. It is a collection of tools for programming AVR chips on OS X. The most important part being &lt;a title=&#34;AVRDUDE&#34; href=&#34;http://www.nongnu.org/avrdude/&#34;&gt;AVRDUDE&lt;/a&gt;. The next thing you need to do is bookmark &lt;a title=&#34;Fuse Calc&#34; href=&#34;http://www.engbedded.com/fusecalc&#34;&gt;AVR fuse calculator&lt;/a&gt;. When programming AVR there are something called fuse bits. There are bits which you store in flash memory which affect how the AVR chip will work. It is important to not screw up these settings because if you do it wrong you might not be able to program it again. The fuse bits can be used to set the way the AVR chip should be programmed.&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Hardware&lt;/h3&gt;

&lt;p&gt;When developing electronics projects I prefer to have the important data sheets printed out. So I recommend printing out the &lt;a href=&#34;http://www.atmel.com/Images/doc2535.pdf&#34;&gt;ATtiny13 datasheet&lt;/a&gt; found at atmel.com. And if you like me use the &lt;a href=&#34;https://www.olimex.com/Products/AVR/Programmers/AVR-ISP500/&#34;&gt;AVR-ISP500 programmer&lt;/a&gt; from Olimex get its &lt;a href=&#34;https://www.olimex.com/Products/AVR/Programmers/AVR-ISP500/resources/AVR-ISP500.pdf&#34;&gt;manual&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now I am not going to repeat all the great information found in all these data sheets and manual, but I will try to fill in the blanks. Connecting all this information to get you to program your AVR chip is not always straight forward.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Setting up the software&lt;/h2&gt;

&lt;p&gt;Follow the&lt;a href=&#34;http://www.obdev.at/products/crosspack/index.html&#34;&gt; tutorial at CrossPack&lt;/a&gt;. You then get a Makefile containing these settings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEVICE = atmega8
CLOCK = 8000000
PROGRAMMER = #-c stk500v2 -P avrdoper
OBJECTS = main.o
FUSES = -U hfuse:w:0xd9:m -U lfuse:w:0x24:m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is figuring what these settings should be for your device. You can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;avrdude -c stk500v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To  get a list over supported AVR chips, or parts as AVRDUDE will refer to them. But really the easiest way to write the DEVICE name is to just write the name of the chip is small letters. So ATtiny13 becomes &lt;em&gt;attiny13. &lt;/em&gt;I actually have a ATtiny13V, but you should not add the V. It is not really a significantly different model.&lt;/p&gt;

&lt;p&gt;The next problem is specifying the programmer. This can be confusing. You do not actually write &lt;em&gt;AVR-ISP500&lt;/em&gt;, even though that is what you have. What matters is the protocol. The &lt;em&gt;AVR-ISP500 &lt;/em&gt;uses the STK500v2 protocol, so that is what matters to AVRDUDE. This is probably because mutliple manufactureres probably make programmers which act the same, but they need to be given unqiue names to distinguish each product.&lt;/p&gt;

&lt;p&gt;Now you might think that you should supply &lt;code&gt;avrdoper&lt;/code&gt; to the &lt;code&gt;-P&lt;/code&gt; argument. But that is for another programmer implementing the STK500v2 protocol. If the programmer acted as a regular USB devices you could just write &lt;code&gt;-P USB&lt;/code&gt;. But AVR-ISP500 uses a serial port over USB. I do not really know what that means. It is sort of like emulating a serial port over USB. So this serial port only exists logically on your Mac not physically. This gives problems when trying to find it on your Mac. You can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls /dev/cu.*
/dev/cu.Bluetooth-Modem    /dev/cu.Bluetooth-PDA-Sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to get a list of serial devices. Unfortunatly our serial device is not there. That is because it is logical and created on the fly. So you have to actually plug in your &lt;em&gt;AVR-ISP500&lt;/em&gt; into the USB port before it pops up in the list. The name will be different for different computers. On my computer it shows up as &lt;code&gt;/dev/cu.usbmodemfa121&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now the final setting to figure out are the fuses. I got mine from chapter 1, page 28 of the book &lt;a title=&#34;tiny AVR projects&#34; href=&#34;http://www.amazon.com/tinyAVR-Microcontroller-Projects-Evil-Genius/dp/0071744541&#34;&gt;tinyAVR Microcontroller Projects for the Evil Genius&lt;/a&gt;. They set high fuse to 0xFF and low fuse to 0x73. Those bits will mean different things for different AVR chips. To find out what it means go to the &lt;a href=&#34;http://www.engbedded.com/fusecalc&#34;&gt;AVR Fuse Calculator&lt;/a&gt; chose your AVR chip. In my case ATtiny13. Scroll down past all the individual fuse bits and input the high and low fuse bits 0xFF and 0x73. That means we do not enable any of the high bits because, you need to set a bit to 0 to enable it. On the low bits we enable SPIEN, SUT1 and SUT0. The important part is that we enable the SPIEN bit, because that is what allows us to program the AVR chip using a serial interface called SPI. That is what AVR-ISP500 uses. So the important section in my Makefile ended up being changed to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEVICE = attiny13
CLOCK = 8000000
PROGRAMMER = -c stk500v2 -P /dev/cu.usbmodemfa121
OBJECTS = main.o
FUSES = -U lfuse:w:0x73:m -U hfuse:w:0xff:m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we got the software configured. What is left is getting the hardware configured.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Configure the Hardware&lt;/h2&gt;

&lt;p&gt;Before going into details, let me just tell you that hooking up the programmer to your AVR chip is a lot easier than I thought at first. You do not really need to put in any extra components: capacitors, resistors etc. You do not even need to supply a power source. The programmer will give you everything including power through its cable.&lt;/p&gt;

&lt;p&gt;Just put your AVR chip down on the breadboard. Look at your AVR-ISP500 manual and your ATtiny13 datasheet and make sure you connect the 6 pins from your programmer to the right 6 pins on your AVR chip. Here are some tips for each pin:
&lt;ol&gt;
    &lt;li&gt;&lt;span style=&#34;line-height: 14px;&#34;&gt;Serial input (abbriviated MISO) goes from pin 1 on programmer to pin 6 on ATtiny13&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;Target VCC is the same as VCC on your AVR chip. This is how the chip gets power.&lt;/li&gt;
    &lt;li&gt;Serial clock connects to pin 7 on AVR&lt;/li&gt;
    &lt;li&gt;Serial output (MOSI) to pin 5&lt;/li&gt;
    &lt;li&gt;Target reset connects to pin 1 on your ATtiny, which is the reset pin. When it goes LOW it will reset the chip. E.g. starting program over again.&lt;/li&gt;
    &lt;li&gt;Ground (GND). Connect to pin 4, which is GND on the AVR.&lt;/li&gt;
&lt;/ol&gt;
The Olimex AVR-ISP500 manual shows pictures of the connectors to help you identify where the individual pins are. I am using narrow cable with 6 pins on the right side on the image below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0553.jpg&#34;&gt;&lt;img class=&#34;size-medium wp-image-4 aligncenter&#34; src=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0553.jpg?w=300&#34; alt=&#34;IMG_0553&#34; width=&#34;300&#34; height=&#34;218&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you pull out the cable it is easy to compare with the Olimex manual.&lt;/p&gt;

&lt;p&gt;&lt;caption id=&#34;attachment_5&#34; align=&#34;aligncenter&#34; width=&#34;213&#34;&gt;&lt;a href=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0559.jpg&#34;&gt;&lt;img class=&#34;size-medium wp-image-5&#34; src=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0559.jpg?w=213&#34; alt=&#34;AVR-ISP500 USB based AVR programmer from Olimex, implementing STK500v2 protocol&#34; width=&#34;213&#34; height=&#34;300&#34; /&gt;&lt;/a&gt; AVR-ISP500 USB based AVR programmer from Olimex, implementing STK500v2 protocol&lt;/caption&gt;&lt;/p&gt;

&lt;p&gt;A thing to note about the cable is the pins get turn upside down. So if you turn the programmer so that &lt;strong&gt;pin 1 is at the lower left&lt;/strong&gt; as shown in the manual, it will be the &lt;strong&gt;upper left&lt;/strong&gt; at the end of the cable. In the picture below I have turned the plug so that the the &lt;strong&gt;red&lt;/strong&gt; cable is actually &lt;strong&gt;pin 2&lt;/strong&gt; and the &lt;strong&gt;yellow&lt;/strong&gt; cable below is&lt;strong&gt; pin 1&lt;/strong&gt;. If in doubt measure resistance with your multi meter at both ends, to make sure you are not mixing up which pin is which. If you guessed right, there should be approximatly zero resistance measured.&lt;/p&gt;

&lt;p&gt;&lt;caption id=&#34;attachment_6&#34; align=&#34;aligncenter&#34; width=&#34;300&#34;&gt;&lt;a href=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0549.jpg&#34;&gt;&lt;img class=&#34;size-medium wp-image-6 &#34; src=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0549.jpg?w=300&#34; alt=&#34;IMG_0549&#34; width=&#34;300&#34; height=&#34;231&#34; /&gt;&lt;/a&gt; Yellow: MISO, Red: Vcc, Orange: SCK, Blue: MOSI, Green: Reset, White: GND&lt;/caption&gt;&lt;/p&gt;

&lt;p&gt;Below you can see how I connected all the pins from the programmer to the chip. This is the simple project from chapter 1 of the Evil Genius book. But the important thing here is how the cables are connected from the programmer to the ATtiny13 chip, because that is all you need. You do not need the LEDs, buttons, resitors and capacitor I put in.&lt;/p&gt;

&lt;p&gt;&lt;caption id=&#34;attachment_7&#34; align=&#34;aligncenter&#34; width=&#34;300&#34;&gt;&lt;a href=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0560.jpg&#34;&gt;&lt;img class=&#34; wp-image-7 &#34; src=&#34;http://pluggerogkontakter.files.wordpress.com/2013/03/img_0560.jpg?w=300&#34; alt=&#34;IMG_0560&#34; width=&#34;300&#34; height=&#34;176&#34; /&gt;&lt;/a&gt; Simple setup from Evil Genius book. Allows us to turn on toggle to LEDs with push buttons.&lt;/caption&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>